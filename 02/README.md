## Цель практической работы
### Научиться:

Работать с основными командами Linux;
писать простые консольные утилиты на Python;
обрабатывать переданные в URL параметры разных типов;
возвращать пользователю форматированный текст с помощью HTML-тегов.

*Что входит в работу*

```Задача 1. Список процессов.```

```Задача 2. Средний размер файла.```

```Задача 3. Дешифратор.```

```Задача 4. Хорошего дня!```

```Задача 5. Максимальное число.```

```Задача 6. Превью файла.```

```Задача 7. Учёт финансов.```

## Задача 1. Список процессов
### Что нужно сделать
С помощью команды ps можно посмотреть список запущенных процессов.
С флагами aux эта команда выведет информацию обо всех процессах, запущенных в системе.

Запустите эту команду и сохраните выданный результат в файл:

```$ ps aux > output_file.txt```

Столбец RSS показывает информацию о потребляемой памяти в байтах.

Напишите функцию ```get_summary_rss```, которая на вход принимает путь до файла с результатом выполнения команды ps aux, а возвращает суммарный объём потребляемой памяти в человекочитаемом формате. Это означает, что ответ надо перевести в байты, килобайты, мегабайты и так далее.

*Ответ нужно вывести в одной единице измерения:*

```780 Б → 780 Б;```

```7 168 Б → 7 Кб;```

```220 200 960 Б → 210 Мб;```

```2 147 483 648 Б → 2 Гб.```

#### Советы и рекомендации
Для разбиения строки по столбцам можно воспользоваться функцией ```split``` без аргументов:
```
columns = line.split()
```
Так как первой строкой является заголовок, её можно отбросить при расчётах суммарного объёма потребляемой памяти. Это можно сделать, например, с помощью среза:
```
lines = output_file.readlines()[1:]
```

Используйте цикл, чтобы перевести байты в максимальную единицу измерения. Проверьте, что будет, если ввести слишком большое число.

*Что оценивается*

Результат выводится в человекочитаемом формате (B, KiB, MiB, …).
Путь к файлу вынесен в отдельную переменную.
Запуск функции происходит в блоке ```__main__.```


## Задача 2. Средний размер файла
*Что нужно сделать*

Удобно направлять результат выполнения команды напрямую в программу с помощью конвейера ```(pipe)```:
```
$ ls -l | python3 get_mean_size.py
```
Напишите функцию ```get_mean_size```, которая на вход принимает результат выполнения команды ```ls -l```, а возвращает средний размер файла в каталоге.

*Советы и рекомендации*
Конвейер ```(pipe)``` — это механизм передачи данных со стандартного потока вывода одной программы на стандартный поток ввода другой программы. Пример запуска конвейера:
```
$ ls -R | grep “\.txt” | wc -w 
1)      2)             3)
```
1) Получаем рекурсивно все файлы в текущем каталоге.
2) Получаем из них файлы с расширением ```.txt```.
3) Получаем общее количество слов в ```.txt```-файлах.
Получить входные данные можно следующим образом:
```
import sys 
 ```
```
data = sys.stdin.read()
```
Вывод можно делать с помощью того же ```print```.

Входные данные можно получить сразу в виде списка строк:
```
lines = sys.stdin.readlines()
```
Первая строка не является информацией о файле, поэтому её можно отбросить при прочтении входных данных:
```
lines = sys.stdin.readlines()[1:]
```
Кстати, программа также может получать информацию из файла и из результата выполнения другой команды или программы.
```
$ ls -l > ls.txt 
$ python3 get_mean_size.py < ls.txt 
$ cat ls.txt | python3 get_mean_size.py 
 ```
```
cat <filename> выводит содержимое файла.
```
Проверьте, как программа работает на пустой директории:
```$ mkdir empty```

```$ ls -l empty/ | python3 get_mean_size.py```

*Что оценивается*
Программа поддерживает обработку входных данных через конвейер.
Программа обрабатывает случай, когда файлов нет или не удаётся получить их размер.
Получение входных данных и вывод результата происходит в блоке ```__main__```.

### Задача 3. Дешифратор

*Что нужно сделать*

Вася решил передать Пете шифрограмму.
Поскольку о промышленных шифрах Вася ничего не знает, он решил зашифровать сообщение следующим образом: он посылает Пете строку.

Каждый символ строки — либо буква, либо пробел, либо знак препинания.
Если после какой-то буквы стоит точка, значит, мы оставляем букву без изменений (об одной точке Вася задумался, чтобы усложнить расшифровку). Саму точку при этом надо удалить.
Если после какой-то буквы стоят две точки, то предыдущий символ надо стереть. Обе точки при этом тоже нужно удалить.
Возможна ситуация, когда сообщение после расшифровки будет пустым. В качестве результата можно вернуть просто пустую строку.
Примеры шифровок-расшифровок:

```абра-кадабра. → абра-кадабра```

```абраа..-кадабра → абра-кадабра```

```абраа..-.кадабра → абра-кадабра```

```абра--..кадабра → абра-кадабра```

```абрау...-кадабра → абра-кадабра (сначала срабатывает правило двух точек, потом правило одной точки)```

```абра........ → <пустая строка>```

```абр......a. → a```

```1..2.3 → 23```

```. → <пустая строка>```

```1....................... → <пустая строка>```

Помогите Пете написать программу для расшифровки.
Напишите функцию ```decrypt```, которая принимает на вход шифр в виде строки, а возвращает расшифрованное сообщение.

Программа должна работать через конвейер ```(pipe)```:

```$ echo  ‘абраа..-.кадабра’ | python3 decrypt.py ```
```абра-кадабра```

Команда ```echo``` выводит текст (в стандартный поток вывода).

*Советы и рекомендации*
Рассмотрите несколько алгоритмов. Какой будет быстрее работать? Какой будет использовать меньше памяти?
Не забудьте рассмотреть крайние случаи.
Что оценивается
Программа поддерживает обработку входных данных через конвейер.
Программа правильно расшифровывает все примеры из условия.
Получение входных данных и вывод результата происходит в блоке ```__main__```.

### Задача 4. Хорошего дня!
Что нужно сделать
Реализуйте ```endpoint /hello-world/<имя>```, который возвращает строку ```«Привет, <имя>. Хорошей пятницы!»```. Вместо хорошей пятницы ```endpoint``` должен уметь желать хорошего дня недели в целом, на русском языке.

*Пример запроса, сделанного в субботу:*

```/hello-world/Саша  →  Привет, Саша. Хорошей субботы!```

*Советы и рекомендации*

Текущий день недели можно узнать так:
```
from datetime import datetime 
weekday = datetime.today().weekday()
```
Обратите внимание, что ```weekday()``` возвращает число от ```0``` до ```6```.
Как лучше хранить названия дней недели? Посмотрите, сколько памяти занимают кортеж, список и словарь с одними и теми же данными с помощью метода ```getsizeof``` из модуля ```sys```:
```
import sys 
 
print(sys.getsizeof(weekdays_tuple)) 
print(sys.getsizeof(weekdays_list)) 
print(sys.getsizeof(weekdays_dict))
```
*Что оценивается*

В понедельник endpoint желает хорошего понедельника, во вторник — вторника и так далее.
При изменении имени в URL endpoint возвращает сообщение с изменённым именем.
Выбран оптимальный способ хранения названий дней недели.

###Задача 5. Максимальное число

*Что нужно сделать*

Реализуйте endpoint, начинающийся с ```/max_number```, в который можно передать список чисел, разделённых слешем ```/```. Endpoint должен вернуть текст ```«Максимальное переданное число {number}»```, где ```number``` — выделенное курсивом наибольшее из переданных чисел.

### Примеры:
```
/max_number/10/2/9/1
Максимальное число: 10
```
```
/max_number/1/1/1/1/1/1/1/2
Максимальное число: 2
```
*Советы и рекомендации*

Для обработки списка чисел, разделённых слешем, потребуется тип URL-параметра ```path```.
Так как пользователь может передать в параметры что угодно, нужно сделать дополнительную проверку — действительно ли переданы числа, а не что-то другое.
Обратите внимание, что сравнивать строки неправильно:
```9 < 10, но ‘9’ > ‘10’```
Обратите внимание, что функция ```str.isdigit``` не учитывает отрицательные числа и числа с плавающей точкой.

*Что оценивается*

В ```endpoint``` можно передать неограниченное количество чисел.
Обрабатывается запрос, когда в URL передано не число.

### Задача 6. Превью файла

*Что нужно сделать*
Реализуйте endpoint, который показывает превью файла, принимая на вход два параметра: ```SIZE (int) и RELATIVE_PATH``` — и возвращая первые ```SIZE``` символов файла по указанному в ```RELATIVE_PATH``` пути.

```Endpoint``` должен вернуть страницу с двумя строками.

В первой строке будет содержаться информация о файле: его абсолютный путь и размер прочитанного содержимого в символах, а во второй строке — первые ```SIZE``` символов из файла:
```
<abs_path> <result_size><br> 
<result_text>
```
где ```abs_path``` — написанный жирным абсолютный путь до файла;
```result_text``` — первые ```SIZE``` символов файла;
```result_size``` — длина ```result_text``` в символах.

Перенос строки осуществляется с помощью HTML-тега ```<br>```.

#### Пример:
```
/head_file/8/docs/simple.txt
/home/user/module_2/docs/simple.txt 8
hello wo
/head_file/100/docs/simple.txt
/home/user/module_2/docs/simple.txt 12
hello world!
```
*Советы и рекомендации*

Обратите внимание, что ```result_size``` — это не запрашиваемое количество символов, а прочитанное количество символов. Это показано в примере второго запроса: запрошено ```100``` символов, а прочитано лишь ```12```.

Абсолютный путь до файла можно узнать так:
```
import os 
abs_path = os.path.abspath(‘<file_name>’)
```
Функция ```file.read``` также может принимать на вход количество символов, которое нужно прочитать:

```file.read(SIZE)```

Такой способ гораздо лучше обычного среза ```file.read()[:SIZE]```, ибо не приходится читать файл целиком. Это полезно, когда файл имеет очень большой размер.
Учтите, что приложение может быть запущено из другой директории, поэтому относительный путь может поменяться. Вспомните рекомендацию к ```endpoint``` ```/get_random_word``` из модуля ```1```.

*Что оценивается*

Отображается абсолютный, а не относительный путь.
Результат возвращается с переносом строки и с заключённой в нужные HTML-теги информацией.
Файл не считывается целиком.
Размер и относительный путь имеют правильные URL-параметры.

### Задача 7. Учёт финансов

*Что нужно сделать*

Реализуйте приложение для учёта финансов, умеющее запоминать, сколько денег было потрачено за день, а также показывать затраты за отдельный месяц и за целый год.

В программе должно быть три ```endpoints```:

```/add/<date>/<int:number>``` — сохранение информации о совершённой в рублях трате за какой-то день;
```/calculate/<int:year>``` — получение суммарных трат за указанный год;
```/calculate/<int:year>/<int:month>``` — получение суммарных трат за указанные год и месяц.
Дата для ```/add/``` передаётся в формате ```YYYYMMDD```, где ```YYYY — год```, ```MM — месяц (от 1 до 12)```, ```DD — число (от 01 до 31)```. Гарантируется, что переданная дата имеет такой формат и она корректна (никаких 31 февраля).

*Советы и рекомендации*

У словаря есть метод ```setdefault```, который возвращает значение по ключу, а если такого ключа нет, инициализирует элемент заданным значением.

Вариант с большим количеством вложенных условий:
```
if year in storage: 
if month in storage[year]: 
        storage[year][month] += expense 
    else: 
        … 
else: 
    …
```
Вариант с использованием ```setdefault```:
```
storage.setdefault(year, {}).setdefault(month, {}) 
storage[year][month] += expense
```
В словаре эффективнее хранить суммарные затраты, чтобы не пересчитывать их каждый раз, а сразу отдавать ```storage[year]['total']```.